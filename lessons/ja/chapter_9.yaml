- title: 第９章 - プロジェクト構造
  content_markdown: >
    これまでのコード例はすべて単一のファイルでした。
    ここで、コードをどのように整理し、他の人と共有できるかについて話し合いましょう！
- title: モジュール
  content_markdown: |
    すべてのRustプログラムやライブラリは*クレート*です。

    すべてのクレートは、*モジュール* の階層で構成されています。

    すべてのクレートにはルートモジュールがあります。

    モジュールは、グローバル変数、関数、構造体、トレイト、さらには他のモジュールさえも保持することができます！

    Rustでは、ファイルとモジュールツリー階層が1対1で対応しているわけではありません。コード内で明示的にモジュールツリーを構築する必要があります。
- title: プログラムを書く
  content_markdown: |
    プログラムには `main.rs` というファイルにルートモジュールがあります。
- title: ライブラリを書く
  content_markdown: |
    ライブラリには、`lib.rs` というファイルにルートモジュールがあります。
- title: 他のモジュール、クレートを参照する
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Af64%3A%3Aconsts%3A%3API%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Welcome%20to%20the%20playground!%22)%3B%0A%20%20%20%20println!(%22I%20would%20love%20a%20slice%20of%20%7B%7D!%22%2C%20PI)%3B%0A%7D%0A
  content_markdown: >
    モジュール内の項目は、完全なモジュールパス `std::f64::consts::PI` を使用して参照できます。


    より簡単な方法は **use** キーワードです。これにより、コード全体でフルパスを使用せずに使用したいモジュールから特定の項目を指定できます。例えば、`use std::f64::consts::PI` とすることで、メイン関数内で識別子 `PI` をそのまま使用できます。


    **std** は、Rust の **標準ライブラリ** のクレートであり、オペレーティングシステムと対話するための便利なデータ構造や関数が豊富に含まれています。


    コミュニティによって作成されたクレートの検索可能なディレクトリは、[https://crates.io](https://crates.io/) で見つけることができます。
- title: 複数のアイテムを参照する
  content_markdown: |
    複数の項目を単一のモジュールパスで参照することができます。例えば、以下のように記述します:

    ```rust
    use std::f64::consts::{PI, TAU};
    ```

    フェリスは **TAU** を食べず、**PI** だけを食べます。
- title: モジュールを作成する
  content_markdown: |
    Rustでは、コードをファイル構造に密接に関連付けてモジュールを作成できます。

    モジュールを宣言する方法は2つあります。
    例えば、モジュール `foo` は以下のように表現できます:

    **ファイル**として:
      - `foo.rs`

    **ディレクトリ**として:
      - ディレクトリ `foo` 内に `mod.rs` というファイルを置く

    この構造により、コードの整理と管理がしやすくなります。

- title: モジュール階層
  content_markdown: >
    モジュールは他のモジュールに依存することができます。親モジュールとそのサブモジュールの関係を確立するためには、親モジュール内で次のように記述します:


    ```rust

    mod foo;

    ```


    この宣言は、`foo.rs` または `foo/mod.rs` という名前のファイルを探し、その内容をこのスコープ内の `foo` という名前のモジュールとして挿入します。

    これにより、モジュール間の階層構造を明確にし、コードの再利用や管理を容易にします。
- title: インラインモジュール
  content_markdown: >
    サブモジュールは、モジュールのコード内に直接インライン化することができます。


    インラインモジュールの非常に一般的な用途として、ユニットテストの作成があります。Rustをテスト用に使用する場合にのみ存在するインラインモジュールを作成します。


    ```rust

    // このマクロは、Rustがテストモードでないときにこのインラインモジュールを削除します。

    #[cfg(test)]

    mod tests {
        // 親モジュールには即座にアクセスできないことに注意してください。
        // 明示的に指定する必要があります。
        use super::*;

        // テストはここに記述します...
    }

    ```
- title: 内部モジュール参照
  content_markdown: >
    Rustには、`use`パスで使用できるいくつかのキーワードがあり、目的のモジュールをすばやく取得できます。それぞれのキーワードは以下のように機能します：

    - **`crate`**:  
      `crate`は、クレートのルートモジュールを指します。これは、クレート全体のエントリーポイントであり、他のモジュールをインポートする際の基点として使用されます。

      ```rust
      use crate::some_module;
      ```

    - **`super`**:  
      `super`は、現在のモジュールの親モジュールを指します。階層構造の中で1つ上のレベルにあるモジュールにアクセスするために使います。

      ```rust
      mod parent {
          pub mod child {
              pub fn function() {}
          }
      }

      mod another_child {
          use super::parent::child::function;
      }
      ```

    - **`self`**:  
      `self`は、現在のモジュール自身を指します。モジュール内で自身を再帰的に参照する場合に便利です。

      ```rust
      mod my_module {
          pub fn my_function() {}

          mod nested {
              use self::super::my_function;
          }
      }
      ```

    これらのキーワードを活用することで、モジュール間の関係を明示的に示し、コードの可読性と保守性を向上させることができます。

- title: 探検
  content_markdown: >
    デフォルトでは、*モジュール*のメンバーはモジュールの外部からアクセスできません（その子モジュールでさえもアクセスできません！）。
    モジュールのメンバーをアクセス可能にするには、`pub`キーワードを使用します。


    デフォルトでは、*クレート*のメンバーはクレートの外部からアクセスできません。
    クレートのメンバーをアクセス可能にするには、クレートの*ルートモジュール*（`lib.rs`または`main.rs`）で
    それらを`pub`としてマークします。

- title: 構造の可視化
  content_markdown: >
    関数と同様に、構造体も `pub` を使用してモジュールの外部に公開したいものを宣言できます。
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20SeaCreature%20struct%20will%20be%20usable%20outside%20of%20our%20module%0Apub%20struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20animal_type%3A%20String%2C%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20pub%20arms%3A%20i32%2C%0A%20%20%20%20pub%20legs%3A%20i32%2C%0A%20%20%20%20%2F%2F%20let's%20keep%20our%20weapon%20private%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A
- title: Prelude
  content_markdown: |
    `Vec` や `Box` をインポートするための `use` がないのに、どこでもアクセスできる理由を不思議に思っているかもしれません。それは標準ライブラリのモジュール `prelude` によるものです。

    Rust の標準ライブラリでは、`std::prelude::*` でエクスポートされているものは Rust のあらゆる部分で自動的に利用可能です。これは `Vec` や `Box` だけでなく、他のもの（Option、Copy など）にも当てはまります。
- title: あなた独自のPrelude
  content_markdown: >
    標準ライブラリのプレリュードのおかげで、ライブラリが独自のプレリュードモジュールを開始点として持つことが一般的です。
    これにより、ユーザーはライブラリを使用するための最も一般的なデータ構造をインポートすることができます（例: `use my_library::prelude::*`）。

    このプレリュードは、あなたのクレートを使うプログラムやライブラリで自動的に使用されるわけではありませんが、
    人々がどこから始めればよいか分かるようにするための良い慣習です。


    フェリス「良いRustaceanになって、仲間のカニを助けるために良いプレリュードを提供しよう！」

- title: 第９章 - まとめ
  content_markdown: >
    これで、世界に向けて準備されたRustアプリケーションやライブラリを作成する際のいくつかのテクニックを身につけました。
    すべてを覚えておくことについて心配しないでください。あなたのライブラリが成長し、他の人々に使用されるようになると、各マイルストーンで何が最も効果的かがわかるでしょう。


    リソース:

    - [Rust APIを書くためのガイドライン](https://rust-lang.github.io/api-guidelines/)
